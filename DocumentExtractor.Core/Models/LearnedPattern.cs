using System;
using System.ComponentModel.DataAnnotations;
using System.Text.RegularExpressions;

namespace DocumentExtractor.Core.Models
{
    /// <summary>
    /// Represents a learned pattern for extracting specific fields from documents.
    /// This is the core of our "local learning intelligence" - patterns that get smarter over time.
    /// 
    /// Each pattern is specific to a supplier and field combination (e.g., "ConEd" + "AccountNumber").
    /// As users correct extractions, we create new patterns or improve existing ones.
    /// 
    /// VB.NET to C# Learning Notes:
    /// - Regular expressions work similarly but use different syntax for some operations
    /// - Nullable reference types (string?) help prevent null reference exceptions
    /// - Record types and init-only properties are newer C# features for immutable data
    /// </summary>
    public class LearnedPattern
    {
        /// <summary>
        /// Unique identifier for this pattern.
        /// </summary>
        public string Id { get; set; } = Guid.NewGuid().ToString();

        /// <summary>
        /// The supplier/company this pattern applies to (e.g., "ConEd", "Verizon", "AT&T").
        /// Case-insensitive matching is used when applying patterns.
        /// </summary>
        [Required]
        [MaxLength(100)]
        public string Supplier { get; set; } = string.Empty;

        /// <summary>
        /// The field name this pattern extracts (e.g., "AccountNumber", "TotalAmount", "DueDate").
        /// Should match the FieldName in ExtractedField for consistency.
        /// </summary>
        [Required]
        [MaxLength(100)]
        public string FieldName { get; set; } = string.Empty;

        /// <summary>
        /// The regular expression pattern used for extraction.
        /// Example: @"Account\s*Number:?\s*(\d{10,12})" to extract 10-12 digit account numbers.
        /// 
        /// The pattern should have exactly one capture group () that captures the actual value.
        /// The surrounding text helps ensure we're extracting the right field.
        /// </summary>
        [Required]
        [MaxLength(1000)]
        public string RegexPattern { get; set; } = string.Empty;

        /// <summary>
        /// Success rate of this pattern (0.0 to 1.0).
        /// Calculated as: successful_extractions / total_attempts
        /// Patterns with higher success rates are preferred.
        /// </summary>
        [Range(0.0, 1.0)]
        public double SuccessRate { get; set; } = 0.0;

        /// <summary>
        /// Total number of times this pattern has been used.
        /// Higher usage count indicates a more established pattern.
        /// </summary>
        public int UsageCount { get; set; } = 0;

        /// <summary>
        /// Number of successful extractions using this pattern.
        /// Used to calculate SuccessRate.
        /// </summary>
        public int SuccessCount { get; set; } = 0;

        /// <summary>
        /// When this pattern was last used for extraction.
        /// Helps identify obsolete patterns that might need updating.
        /// </summary>
        public DateTime LastUsed { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// When this pattern was first created.
        /// </summary>
        public DateTime CreatedDate { get; set; } = DateTime.UtcNow;

        /// <summary>
        /// Human-readable description of what this pattern does.
        /// Example: "Extracts 10-digit account number after 'Account Number:' label"
        /// </summary>
        [MaxLength(500)]
        public string? Description { get; set; }

        /// <summary>
        /// Example text that this pattern successfully matched.
        /// Useful for debugging and pattern validation.
        /// </summary>
        [MaxLength(1000)]
        public string? ExampleMatch { get; set; }

        /// <summary>
        /// The expected data type for values extracted by this pattern.
        /// Helps with validation and formatting.
        /// </summary>
        public FieldType ExpectedFieldType { get; set; } = FieldType.Text;

        /// <summary>
        /// Whether this pattern was created automatically or manually by a user.
        /// Auto-generated patterns might need more validation.
        /// </summary>
        public bool IsAutoGenerated { get; set; } = true;

        /// <summary>
        /// Priority level for this pattern when multiple patterns match the same field.
        /// Higher priority patterns are tried first.
        /// </summary>
        public int Priority { get; set; } = 0;

        /// <summary>
        /// Whether this pattern is currently active and should be used.
        /// Inactive patterns are kept for historical purposes but not used in extraction.
        /// </summary>
        public bool IsActive { get; set; } = true;

        /// <summary>
        /// Version number for this pattern.
        /// Incremented when pattern is updated based on user corrections.
        /// </summary>
        public int Version { get; set; } = 1;

        /// <summary>
        /// Minimum confidence score this pattern typically achieves.
        /// Used to filter low-quality patterns.
        /// </summary>
        [Range(0.0, 1.0)]
        public double MinimumConfidence { get; set; } = 0.0;

        /// <summary>
        /// Maximum confidence score this pattern has achieved.
        /// </summary>
        [Range(0.0, 1.0)]
        public double MaximumConfidence { get; set; } = 1.0;

        /// <summary>
        /// Compiled regex for better performance.
        /// This is not stored in the database - it's compiled on-demand.
        /// 
        /// C# Note: The [NonSerialized] attribute prevents this from being serialized.
        /// In Entity Framework, you'd use [NotMapped] instead.
        /// </summary>
        [System.Text.Json.Serialization.JsonIgnore]
        public Regex? CompiledRegex { get; private set; }

        /// <summary>
        /// Default constructor.
        /// </summary>
        public LearnedPattern()
        {
            // Property initializers handle most initialization
        }

        /// <summary>
        /// Constructor for creating a new pattern.
        /// </summary>
        /// <param name="supplier">Supplier name</param>
        /// <param name="fieldName">Field name to extract</param>
        /// <param name="regexPattern">Regular expression pattern</param>
        /// <param name="description">Optional description</param>
        public LearnedPattern(string supplier, string fieldName, string regexPattern, string? description = null)
        {
            Supplier = supplier;
            FieldName = fieldName;
            RegexPattern = regexPattern;
            Description = description;
            
            // Try to compile the regex to validate it
            try
            {
                CompileRegex();
            }
            catch (ArgumentException ex)
            {
                throw new ArgumentException($"Invalid regex pattern: {regexPattern}", nameof(regexPattern), ex);
            }
        }

        /// <summary>
        /// Compile the regex pattern for better performance.
        /// Call this before using the pattern for extraction.
        /// 
        /// C# Exception Handling Note:
        /// - try/catch blocks work similarly to VB.NET's Try/Catch
        /// - throw statements use 'throw' instead of VB.NET's 'Throw'
        /// </summary>
        public void CompileRegex()
        {
            if (string.IsNullOrWhiteSpace(RegexPattern))
            {
                throw new InvalidOperationException("Cannot compile empty or null regex pattern");
            }

            try
            {
                // RegexOptions.IgnoreCase makes patterns work regardless of text casing
                // RegexOptions.Compiled improves performance for frequently used patterns
                CompiledRegex = new Regex(RegexPattern, RegexOptions.IgnoreCase | RegexOptions.Compiled);
            }
            catch (ArgumentException ex)
            {
                throw new ArgumentException($"Invalid regex pattern '{RegexPattern}': {ex.Message}", ex);
            }
        }

        /// <summary>
        /// Try to extract a field value using this pattern.
        /// Returns the extracted value and confidence score.
        /// 
        /// This method demonstrates tuple return types in C# - similar to VB.NET's tuple syntax.
        /// </summary>
        /// <param name="text">Text to search in</param>
        /// <returns>Tuple with (success, extractedValue, confidence)</returns>
        public (bool Success, string Value, double Confidence) TryExtract(string text)
        {
            if (string.IsNullOrWhiteSpace(text))
                return (false, string.Empty, 0.0);

            // Ensure regex is compiled
            if (CompiledRegex == null)
            {
                try
                {
                    CompileRegex();
                }
                catch
                {
                    return (false, string.Empty, 0.0);
                }
            }

            // Try to find a match
            var match = CompiledRegex!.Match(text);
            if (!match.Success || match.Groups.Count < 2)
                return (false, string.Empty, 0.0);

            // Extract the value from the first capture group
            string extractedValue = match.Groups[1].Value.Trim();
            if (string.IsNullOrWhiteSpace(extractedValue))
                return (false, string.Empty, 0.0);

            // Calculate confidence based on pattern quality and match quality
            double confidence = CalculateExtractionConfidence(match, extractedValue);

            return (true, extractedValue, confidence);
        }

        /// <summary>
        /// Calculate confidence score for an extraction.
        /// This method demonstrates private helper methods and confidence calculation logic.
        /// </summary>
        /// <param name="match">The regex match object</param>
        /// <param name="extractedValue">The extracted value</param>
        /// <returns>Confidence score from 0.0 to 1.0</returns>
        private double CalculateExtractionConfidence(Match match, string extractedValue)
        {
            double confidence = 0.5; // Base confidence

            // Boost confidence based on pattern success rate
            confidence += SuccessRate * 0.3;

            // Boost confidence based on usage count (more used = more trusted)
            double usageBoost = Math.Min(UsageCount / 100.0, 0.1); // Max 0.1 boost
            confidence += usageBoost;

            // Boost confidence if the extracted value matches expected field type
            if (ValidateFieldType(extractedValue))
                confidence += 0.1;

            // Reduce confidence if the match is very short (might be incomplete)
            if (extractedValue.Length < 3)
                confidence -= 0.1;

            // Ensure confidence stays within valid range
            return Math.Max(0.0, Math.Min(1.0, confidence));
        }

        /// <summary>
        /// Validate that the extracted value matches the expected field type.
        /// </summary>
        /// <param name="value">Value to validate</param>
        /// <returns>True if value matches expected type</returns>
        private bool ValidateFieldType(string value)
        {
            return ExpectedFieldType switch
            {
                FieldType.Number => double.TryParse(value.Replace(",", ""), out _),
                FieldType.Currency => value.Contains("$") || double.TryParse(value.Replace("$", "").Replace(",", ""), out _),
                FieldType.Date => DateTime.TryParse(value, out _),
                FieldType.Email => value.Contains("@") && value.Contains("."),
                FieldType.PhoneNumber => value.All(c => char.IsDigit(c) || "()- .".Contains(c)) && value.Count(char.IsDigit) >= 10,
                _ => true // Text and other types are always valid
            };
        }

        /// <summary>
        /// Update pattern statistics after an extraction attempt.
        /// Call this every time the pattern is used to maintain accurate statistics.
        /// </summary>
        /// <param name="wasSuccessful">Whether the extraction was successful and accurate</param>
        public void UpdateStatistics(bool wasSuccessful)
        {
            UsageCount++;
            LastUsed = DateTime.UtcNow;

            if (wasSuccessful)
            {
                SuccessCount++;
            }

            // Recalculate success rate
            SuccessRate = UsageCount > 0 ? (double)SuccessCount / UsageCount : 0.0;
        }

        /// <summary>
        /// Create a new version of this pattern with improved regex.
        /// Used when user corrections suggest the pattern can be improved.
        /// </summary>
        /// <param name="newRegexPattern">Improved regex pattern</param>
        /// <param name="description">Description of the improvement</param>
        /// <returns>New pattern version</returns>
        public LearnedPattern CreateNewVersion(string newRegexPattern, string? description = null)
        {
            var newPattern = new LearnedPattern
            {
                Supplier = this.Supplier,
                FieldName = this.FieldName,
                RegexPattern = newRegexPattern,
                ExpectedFieldType = this.ExpectedFieldType,
                IsAutoGenerated = false, // Improved patterns are considered manual
                Priority = this.Priority + 1, // Higher priority than original
                Version = this.Version + 1,
                Description = description ?? $"Improved version of pattern v{this.Version}",
                CreatedDate = DateTime.UtcNow
            };

            // Validate the new pattern
            try
            {
                newPattern.CompileRegex();
            }
            catch (ArgumentException ex)
            {
                throw new ArgumentException($"Invalid improved regex pattern: {ex.Message}", ex);
            }

            return newPattern;
        }

        /// <summary>
        /// Get a human-readable summary of this pattern's performance.
        /// Useful for debugging and pattern management UI.
        /// </summary>
        /// <returns>Performance summary string</returns>
        public string GetPerformanceSummary()
        {
            string usageLevel = UsageCount switch
            {
                < 10 => "New",
                < 50 => "Developing",
                < 200 => "Established",
                _ => "Mature"
            };

            string successLevel = SuccessRate switch
            {
                < 0.5 => "Poor",
                < 0.7 => "Fair",
                < 0.9 => "Good",
                _ => "Excellent"
            };

            return $"{usageLevel} pattern with {successLevel} success rate " +
                   $"({SuccessCount}/{UsageCount} successful, {SuccessRate:P1})";
        }

        /// <summary>
        /// Override ToString for better debugging.
        /// </summary>
        /// <returns>String representation of this pattern</returns>
        public override string ToString()
        {
            return $"{Supplier}.{FieldName} v{Version}: {RegexPattern} ({GetPerformanceSummary()})";
        }
    }
}