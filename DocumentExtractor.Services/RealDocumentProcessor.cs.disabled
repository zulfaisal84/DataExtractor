using DocumentExtractor.Core.Interfaces;
using DocumentExtractor.Core.Models;
using DocumentExtractor.Data.Context;
using Microsoft.Extensions.Logging;
using Microsoft.EntityFrameworkCore;
using System.Diagnostics;

namespace DocumentExtractor.Services
{
    /// <summary>
    /// Real document processor that integrates OCR, field extraction, and pattern learning
    /// </summary>
    public class RealDocumentProcessor : IDocumentProcessor
    {
        private readonly ITextExtractor _textExtractor;
        private readonly IFieldExtractor _fieldExtractor;
        private readonly IPatternLearning _patternLearning;
        private readonly DocumentExtractionContext _context;
        private readonly ILogger<RealDocumentProcessor> _logger;

        /// <summary>
        /// Initialize the real document processor with all required services
        /// </summary>
        public RealDocumentProcessor(
            ITextExtractor textExtractor,
            IFieldExtractor fieldExtractor,
            IPatternLearning patternLearning,
            DocumentExtractionContext context,
            ILogger<RealDocumentProcessor> logger)
        {
            _textExtractor = textExtractor;
            _fieldExtractor = fieldExtractor;
            _patternLearning = patternLearning;
            _context = context;
            _logger = logger;
        }

        /// <summary>
        /// Process uploaded document with OCR and field extraction
        /// </summary>
        /// <param name="uploadedFile">Information about the uploaded file</param>
        /// <returns>Processed document with extracted fields</returns>
        public async Task<ExtractedDocument> ProcessDocumentAsync(UploadedFileInfo uploadedFile)
        {
            var stopwatch = Stopwatch.StartNew();
            var documentId = Guid.NewGuid();

            try
            {
                _logger.LogInformation("Starting document processing for {FileName} (ID: {DocumentId})", 
                    uploadedFile.OriginalFileName, documentId);

                // Create initial document record
                var document = new ExtractedDocument
                {
                    Id = documentId,
                    FileName = uploadedFile.OriginalFileName,
                    FilePath = uploadedFile.FilePath,
                    FileSizeBytes = uploadedFile.FileSizeBytes,
                    ProcessedDate = DateTime.UtcNow,
                    Status = ProcessingStatus.Processing,
                    Fields = new List<ExtractedField>()
                };

                // Step 1: Extract text using OCR
                _logger.LogInformation("Step 1: Extracting text with OCR for {FileName}", uploadedFile.OriginalFileName);
                
                string extractedText = await _textExtractor.ExtractTextAsync(uploadedFile.FilePath);
                document.RawText = extractedText;

                if (string.IsNullOrWhiteSpace(extractedText))
                {
                    _logger.LogWarning("No text extracted from document: {FileName}", uploadedFile.OriginalFileName);
                    document.Status = ProcessingStatus.Failed;
                    document.ErrorMessage = "No text could be extracted from the document";
                    stopwatch.Stop();
                    document.ProcessingTimeMs = (int)stopwatch.ElapsedMilliseconds;
                    
                    return document;
                }

                _logger.LogInformation("OCR completed. Extracted {TextLength} characters", extractedText.Length);

                // Step 2: Classify document type
                _logger.LogInformation("Step 2: Classifying document type for {FileName}", uploadedFile.OriginalFileName);
                
                document.DocumentType = ClassifyDocumentType(extractedText);
                _logger.LogInformation("Document classified as: {DocumentType}", document.DocumentType);

                // Step 3: Extract structured fields
                _logger.LogInformation("Step 3: Extracting structured fields for {FileName}", uploadedFile.OriginalFileName);
                
                var extractedFields = await _fieldExtractor.ExtractFieldsAsync(extractedText, document.DocumentType);
                
                // Convert to ExtractedField entities
                foreach (var field in extractedFields)
                {
                    var extractedField = new ExtractedField
                    {
                        Id = Guid.NewGuid(),
                        DocumentId = document.Id,
                        FieldName = field.Key,
                        Value = field.Value.Value,
                        Confidence = field.Value.Confidence,
                        Type = DetermineFieldType(field.Key),
                        ExtractedDate = DateTime.UtcNow,
                        Source = "OCR + Pattern Matching",
                        IsVerified = field.Value.Confidence > 0.8 // Auto-verify high confidence fields
                    };
                    
                    document.Fields.Add(extractedField);
                }

                _logger.LogInformation("Extracted {FieldCount} fields from document", document.Fields.Count);

                // Step 4: Determine supplier and calculate confidence
                document.Supplier = ExtractSupplier(extractedText, extractedFields);
                document.OverallConfidence = CalculateOverallConfidence(document.Fields);

                // Step 5: Learn patterns for future processing
                _logger.LogInformation("Step 5: Learning patterns from extracted data");
                
                await LearnPatternsFromDocument(document);

                // Step 6: Set final status
                document.Status = ProcessingStatus.Completed;
                stopwatch.Stop();
                document.ProcessingTimeMs = (int)stopwatch.ElapsedMilliseconds;

                _logger.LogInformation("Document processing completed for {FileName}. " +
                    "Time: {ProcessingTime}ms, Confidence: {Confidence:F1}%, Fields: {FieldCount}",
                    uploadedFile.OriginalFileName, document.ProcessingTimeMs, 
                    document.OverallConfidence * 100, document.Fields.Count);

                return document;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing document {FileName} (ID: {DocumentId})", 
                    uploadedFile.OriginalFileName, documentId);

                stopwatch.Stop();
                
                return new ExtractedDocument
                {
                    Id = documentId,
                    FileName = uploadedFile.OriginalFileName,
                    FilePath = uploadedFile.FilePath,
                    FileSizeBytes = uploadedFile.FileSizeBytes,
                    ProcessedDate = DateTime.UtcNow,
                    Status = ProcessingStatus.Failed,
                    ErrorMessage = ex.Message,
                    ProcessingTimeMs = (int)stopwatch.ElapsedMilliseconds,
                    Fields = new List<ExtractedField>()
                };
            }
        }

        /// <summary>
        /// Classify document type based on extracted text content
        /// </summary>
        /// <param name="text">Extracted text from OCR</param>
        /// <returns>Classified document type</returns>
        private DocumentType ClassifyDocumentType(string text)
        {
            string lowerText = text.ToLowerInvariant();

            // Simple keyword-based classification
            if (lowerText.Contains("invoice") || lowerText.Contains("bill to") || lowerText.Contains("invoice #"))
                return DocumentType.Invoice;
            
            if (lowerText.Contains("utility") || lowerText.Contains("electricity") || lowerText.Contains("gas bill") || 
                lowerText.Contains("water bill") || lowerText.Contains("electric") || lowerText.Contains("kwh"))
                return DocumentType.UtilityBill;
            
            if (lowerText.Contains("phone") || lowerText.Contains("mobile") || lowerText.Contains("telecom") || 
                lowerText.Contains("cellular") || lowerText.Contains("data plan") || lowerText.Contains("verizon") || 
                lowerText.Contains("at&t") || lowerText.Contains("t-mobile"))
                return DocumentType.TelecomBill;

            // Default to invoice if unclear
            return DocumentType.Invoice;
        }

        /// <summary>
        /// Determine field type based on field name
        /// </summary>
        /// <param name="fieldName">Name of the field</param>
        /// <returns>Field type classification</returns>
        private FieldType DetermineFieldType(string fieldName)
        {
            string lowerFieldName = fieldName.ToLowerInvariant();

            if (lowerFieldName.Contains("date") || lowerFieldName.Contains("due"))
                return FieldType.Date;
            
            if (lowerFieldName.Contains("amount") || lowerFieldName.Contains("total") || 
                lowerFieldName.Contains("price") || lowerFieldName.Contains("cost") || lowerFieldName.Contains("$"))
                return FieldType.Currency;
            
            if (lowerFieldName.Contains("account") || lowerFieldName.Contains("invoice") || 
                lowerFieldName.Contains("number") || lowerFieldName.Contains("#"))
                return FieldType.Number;

            return FieldType.Text;
        }

        /// <summary>
        /// Extract supplier/company name from text and fields
        /// </summary>
        /// <param name="text">Raw OCR text</param>
        /// <param name="fields">Extracted fields</param>
        /// <returns>Identified supplier name</returns>
        private string ExtractSupplier(string text, Dictionary<string, (string Value, double Confidence)> fields)
        {
            // Try to find supplier in extracted fields first
            var supplierField = fields.FirstOrDefault(f => 
                f.Key.ToLowerInvariant().Contains("supplier") || 
                f.Key.ToLowerInvariant().Contains("company") ||
                f.Key.ToLowerInvariant().Contains("vendor"));

            if (supplierField.Key != null && !string.IsNullOrWhiteSpace(supplierField.Value.Value))
            {
                return supplierField.Value.Value;
            }

            // Fallback to text analysis for common suppliers
            string lowerText = text.ToLowerInvariant();
            
            if (lowerText.Contains("coned") || lowerText.Contains("con ed") || lowerText.Contains("consolidated edison"))
                return "ConEd";
            
            if (lowerText.Contains("verizon"))
                return "Verizon";
            
            if (lowerText.Contains("acme corp") || lowerText.Contains("acme corporation"))
                return "ACME Corp";
            
            if (lowerText.Contains("pge") || lowerText.Contains("pacific gas"))
                return "PG&E";

            // Try to extract first company-like entity (simple heuristic)
            var lines = text.Split('\n', StringSplitOptions.RemoveEmptyEntries);
            foreach (var line in lines.Take(5)) // Check first 5 lines
            {
                if (line.Length > 3 && line.Length < 50 && 
                    (line.Contains("Corp") || line.Contains("Inc") || line.Contains("LLC") || 
                     line.Contains("Company") || line.Contains("Ltd")))
                {
                    return line.Trim();
                }
            }

            return "Unknown";
        }

        /// <summary>
        /// Calculate overall confidence score based on individual field confidences
        /// </summary>
        /// <param name="fields">List of extracted fields</param>
        /// <returns>Overall confidence score (0.0 to 1.0)</returns>
        private double CalculateOverallConfidence(IList<ExtractedField> fields)
        {
            if (!fields.Any())
                return 0.0;

            // Weighted average with more weight for important fields
            double totalWeight = 0;
            double weightedSum = 0;

            foreach (var field in fields)
            {
                double weight = GetFieldWeight(field.FieldName);
                totalWeight += weight;
                weightedSum += field.Confidence * weight;
            }

            return totalWeight > 0 ? weightedSum / totalWeight : 0.0;
        }

        /// <summary>
        /// Get importance weight for a field type
        /// </summary>
        /// <param name="fieldName">Name of the field</param>
        /// <returns>Weight multiplier (higher = more important)</returns>
        private double GetFieldWeight(string fieldName)
        {
            string lowerFieldName = fieldName.ToLowerInvariant();

            // Critical fields get higher weights
            if (lowerFieldName.Contains("total") || lowerFieldName.Contains("amount"))
                return 3.0;
            
            if (lowerFieldName.Contains("date") || lowerFieldName.Contains("account"))
                return 2.0;
            
            if (lowerFieldName.Contains("supplier") || lowerFieldName.Contains("company"))
                return 2.0;

            return 1.0; // Default weight
        }

        /// <summary>
        /// Learn patterns from successfully processed document
        /// </summary>
        /// <param name="document">Processed document with extracted fields</param>
        private async Task LearnPatternsFromDocument(ExtractedDocument document)
        {
            try
            {
                foreach (var field in document.Fields.Where(f => f.Confidence > 0.7))
                {
                    await _patternLearning.LearnPatternAsync(
                        supplier: document.Supplier,
                        fieldName: field.FieldName,
                        value: field.Value,
                        context: document.RawText,
                        confidence: field.Confidence
                    );
                }

                _logger.LogDebug("Pattern learning completed for document {FileName}", document.FileName);
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Error during pattern learning for document {FileName}", document.FileName);
                // Don't fail the whole process if pattern learning fails
            }
        }
    }
}